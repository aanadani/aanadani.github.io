---
layout: "content"
categories: computer-science algorithms
title:     " البرمجة الديناميكية"
permalink: /:categories/:title.html
type: 'course'
---
<div class="col-12">
  <h2>
  <bdi>
   Dynamic programming - البرمجة الديناميكة
  </bdi>
  </h2>
 <p class="content-p">
  <bdi>
 البرمجة الديناميكية هي عبارة تقنية في برمجة الحاسوب أي التي تساعد بفاعلية في حل مجموعة من المشاكل التي تحوي مشاكل فرعية متداخلة 
إذا كان من الممكن تقسيم المشكلة إلى مشكلات صغيرة والتي بدورها تنقسم إلى مشكلات فرعية أصغر وإذا كان هناك تداخل بين هذه المشكلات الفرعية ويمكن حفظ الحلول لهذه المشاكل للعودة إليها في المستقبل بهذه الطريقة يمكن تعزيز كفاءة وحدة المعالجة المركزية هذه الطريقة في تخزين الحلول تدعى البرمجة الديناميكية مثل هذه
المشكلات تتضمن حساب قيمة نفس المشكلات الفرعية بشكل متكرر لإيجاد الحل الأمثل
</bdi>
</p>
<h3> : مثال عن البرمجة الديناميكية </h3>
<p class="content-p">
دعنا نقوم بإيجاد سلسلة فيبوناتشي حتى الحد الخامس سلسلة فيبوناتشي هي عبارة سلسلة من الأرقام بحيث كل رقم هو مجموع للرقمين السابقين على سبيل المثال 3-2-1-1-0 هنا كل رقم هو عبارة عن مجموع الرقمين السابقين
</p>
<h3>
 : الخوارزمية 
</h3>
<p class="content-p">
      دعنا نعتبر  <bdi>n</bdi>  عدد الحدود    

</p>
<div class="code-box">
<p>
<pre style="line-height: 1.5em;">
1. If n <= 1, return 1.
2. Else, return the sum of two preceding numbers.
</pre>
</p>
</div>
<h3>قمنا بحساب سلسلة فيبوناتشي حتى الحد الخامس</h3>
<p class="content-p">
البرمجة الديناميكية نعمل عن طريق تخزين نتائج المشكلات الفرعية بحيث عندما نحتاج هذه الحلول تكون في متناول اليد عليها دون الحاجة لإعادة حسابها 
تقنية التخزين حلول المشاكل الفرعية يدعى الحفظ memorization عن طريق حفظ القيم ضمن مصفوفة وبالتالي نوفر الوقت لحساب حلول المشاكل الفرعية التي حسبناها بالفعل
</p>
<div class="code-box">
<p>
<pre style="line-height: 1.5em;">
var m = map(0 → 0, 1 → 1)
function fib(n)
    if key n is not in map m 
        m[n] = fib(n − 1) + fib(n − 2)
    return m[n]
</pre>
</p>
</div>
<p class="content-p">
البرمجة الديناميكية عن طريق الحفظ  هي نهج من اعلى إلى أسفل للبرمجة الديناميكية من خلال عكس الاتجاه للخوارزمية عن طريق البدء من الحالة القاعدية والعمل نحو الحل يمكننا أيضا تنفيذ البرمجة الديناميكية من الأسفل إلى الأعلى 
</p>
<div class="code-box">
<p>
<pre style="line-height: 1.5em;">
function fib(n)
    if n = 0
        return 0
    else
        var prevFib = 0, currFib = 1
        repeat n − 1 times
            var newFib = prevFib + currFib
            prevFib = currFib
            currFib  = newFib
    return currentFib
</pre>
</p>
</div>
<h3> : العودية والبرمجة الديناميكية </h3>
<p class="content-p">
يتم تطبيق البرمجة الديناميكية في الغالب على الخوارزميات العودية وهذا ليس مصادفة معظم مشاكل التحسين تتطلب عوديه وتستخدم البرمجة الديناميكية .
ولكن ليس كل المشاكل التي تستخدم العودية يمكن استخدام البرمجة الديناميكية إلا إذا كان45= هناك مشاكل فرعية متداخلة كما هو الحال في سلسلة فيبوناتشي يمكن ان تصل العودية إلى الحل عن طريق نهج فرق تسد فقط 
هذا هو السبب في أن خوارزمية الفرز بالدمج لا يمكن استخدام البرمجة الديناميكية لأن المشكلات الفرعية لا تتداخل بأي شكل من الأشكال 
</p>
<h3> : خوارزميات الجشع والبرمجة الديناميكية </h3>
<p class="content-p">
خوارزميات الشجع هي مشابهة للبرمجة الديناميكية فهما أداتان للتحسين
خوارزميات الشجع تبحث عن حلول مثالية محلية أو بمعنى أخر خيار جشع على أمثل العثور على أفضل حل مثالي عالمي
وبالتالي يمكن للخوارزميات الشجعة أن تجعل التخمين يبدو الأفضل في هذا الوقت ولكن يمكن  ان لا توصلنا للحل الأمثل على المستوى العام .
أما بالنسبة للبرمجة الديناميكية تقوم بإيجاد الحلول المثلى للمشاكل الفرعية ثم يجعل من اختيار مستنير للجمع هذه الحلول الفرعية لإيجاد الحل الأمثل
</p>
</div>