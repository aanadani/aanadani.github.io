---
layout: "content"
categories: computer-science algorithms
title: " 2 الخوارزميات التراجعية  "
permalink: /:categories/:title.html
type: "course"
---
<div class="col-12">
  <h2>
  <bdi>
    Backtracking - أمثلة عن الخوارزميات التراجعية
  </bdi>
  <h3>   : Rat in Maze problem  - مسألة الفأر في المتاهة   </h3>
  <p class="content-p">
  المتاهة عبارة عن منطقة محاطة بالجدران وبين هذه الجدران يوجد طريق من نقطة البداية حتى الوصول لنقطة والنهاية ويجب علينا أن نسير بدءا من نقطة البداية حتى نصل إلى نقطة النهاية ويمكننا التحرك إلى اليمين والأسفل فقط  
  </p>
  <br/><img class="content-image" src="/assets/img/algorithms/ratinmaze1.jpg" alt="images/ratinmaze1"/>
  <p class="contant-p">
  لنعتبر أن لدينا مصفوفة ثنائية الأبعاد <bdi>maze[width][ height]  </bdi>
  بحيث تكون نقطة البداية <bdi>maze[0][0]</bdi>
  ونقطة النهاية <bdi>maze[width-1][height-1]  </bdi>
  ويجب أن نتحرك من نقطة البداية حتر نصل إلى نقطة النهاية ويمكننا أن نتحرك إلى الأسفل وإلى اليمين فقط أي إذا كنا نريد التحرك للأسفل <bdi>maze[i][j+1]</bdi>
  وإذا أردنا التحرك لليمين <bdi>maze[i+1][j]</bdi>
  يرمز الرقم <bdi>0</bdi>
  في مصفوفة المتاهة إلى الخلية الذي تكون مسدودة ويرمز الرقم<bdi>1</bdi>
  إلى الخلية التي تكون متاحة والتي يمكن استخدامها في المسار الواصل بين البداية والنهاية 
تعرض الشكل التالي متاهة بحيث تشير المربعات الرمادية إلى العدد صفر أي طرق مسدودة أما المربعات البيضاء تشير إلى العدد <bdi>1</bdi>
أي طرق متاحة 
</p>
  <br/><img class="content-image" src="/assets/img/algorithms/ratinmaze2.png" alt="images/ratinmaze2"/>
  <h5> : يمكن تمثيل المتاهة السابقة بالمصفوفة التالية </h5>
   <div class="code-box">
 <p class="content-p">
<pre style="line-height: 1.5em;">
{1, 0, 0, 0}
{1, 1, 0, 1}
{0, 1, 0, 0}
{1, 1, 1, 1}
</pre>
</p>
</div>
<h5> : يعرض الشكل التالي الحل الخاص بالمصفوفة السابقة </h5>
 <br/><img class="content-image" src="/assets/img/algorithms/ratinmaze3.png" alt="images/ratinmaze3"/>
 <h5>: يمكن تمثيل الحل بالمصفوفة التالية </h5>
    <div class="code-box">
 <p class="content-p">
<pre style="line-height: 1.5em;">
{1, 0, 0, 0}
{1, 1, 0, 0}
{0, 1, 0, 0}
{0, 1, 1, 1}
</pre>
</p>
</div>
<h4> : خوارزمية الحل بالاعتماد على الخوارزمية التراجعية </h4>
<p class="content-p">
	  <bdi>sol[x][y]</bdi> نقوم بإنشاء مصفوفة الحل بحيث تكون جميع الخلايا مساوية للصفر -
<br>
 <bdi>bool solveMazeUtil(int maze[N][N], int x, int y, int sol[N][N])</bdi>نقوم بإنشاء تابع عودي والذي يأخذ المصفوفة الأولية ومصفوفة الحل ونقطة البداية -
 <br>
 	نقوم بإنشاء تابع عودي للتحقق إذا كان الموضع الحالي مقبول أي أنه يقع ضمن المصفوفة وغير مسدود بجدار -
 <br>
<bdi>sol[x][y] = 1 </bdi>إذا كان الموضع مقبول نقوم بالتحقق إذا كنا قد اخترنا هذه الخلية سابقا ضمن الحل إذا لم يتم اختيارها سابقا نقوم بتعليم الخلية الحالية في مصفوفة الحل    -
 
<br>
 ونتحقق إذا كانت هذه الخلية هي نقطة النهاية أم لا إذا كانت هي نقطة النهاية نقوم بطباعة مصفوفة الحل ونصل إلى المطلوب 
<br>
<bdi>solveMazeUtil(maze, x + 1, y, sol)</bdi>	إذا لم تكن الخلية هي نقطة النهاية  نجرب التحرك إلى -
<br>
<bdi>solveMazeUtil(maze,   x, y + 1, sol)</bdi>إذا لم يكن التحرك إلى اليمين يوصلنا إلى الحل نجرب التحرك إلى الأسفل -   
<br>
<bdi>sol[x][y] = 0 </bdi>	إذا لم نصل إلى الحل المطلوب من خلال الخطوتين السابقتين نقوم بإزالة تعليم هذه الخلية  -
<br>
أي نتراجع عن اعتبار هذه الخلية جزء من الحل كونها لم توصلنا إلى نقطة النهاية 
</p>
    <div class="code-box">
 <p class="content-p">
<pre style="line-height: 1.5em;">
#include <bits/stdc++.h>
// حجم المتاهة 
#define N 4 
bool solveMazeUtil(int maze[N][N], int x, int y, int sol[N][N]); 
// sol[N][N] دالة مساعدة لطباعة مصفوفة الحل
void printSolution(int sol[N][N]) 
{ 
	for (int i = 0; i < N; i++) { 
		for (int j = 0; j < N; j++) 
			printf(" %d ", sol[i][j]); 
		printf("\n"); 
	} 
} 

/* دالة مساعدة للتحقق من أن القيم المعطاة هي مواقع ملائمة في مصفوفة المتاهة */
bool isSafe(int maze[N][N], int x, int y) 
{ 
	// إن كانت القيم المعطاة خارج المصفوفة، أعدنا قيمة خاطئة
	if (x >= 0 && x < N && y >= 0 && y < N && maze[x][y] == 1) 
		return true; 

	return false; 
} 

/* تحلّ هذه الدالة مسألة فأر في متاهة باستخدام التعقب الخلفي.
solveMazeUtil() تعتمد هذه الدالة اعتمادًا كبيرًا على الدالة
في حلّ هذه المسألة. وتعيد قيمة خاطئة في حال عدم وجود حل لهذه المسألة
وتعيد قيمة صحيحة وتطبع الناتج في حال وجود الحل
يجب الانتباه إلى وجود أكثر من حل لهذه المسألة وأنّ هذه الدالة
تقدم أحد الحلول الممكنة فقط */
bool solveMaze(int maze[N][N]) 
{ 
	int sol[N][N] = { { 0, 0, 0, 0 }, 
					{ 0, 0, 0, 0 }, 
					{ 0, 0, 0, 0 }, 
					{ 0, 0, 0, 0 } }; 

	if (solveMazeUtil(maze, 0, 0, sol) == false) { 
		printf("Solution doesn't exist"); 
		return false; 
	} 

	printSolution(sol); 
	return true; 
} 

/* دالة مساعدة تعاودية لحل مسألة فأر في متاهة */
bool solveMazeUtil(int maze[N][N], int x, int y, int sol[N][N]) 
{ 
	// y و x إن كانت
	// في نقطة النهاية نعيد قيمة صحيحة
	if (x == N - 1 && y == N - 1) { 
		sol[x][y] = 1; 
		return true; 
	} 

	// maze[x][y] التحقق من سلامة القيمة
	if (isSafe(maze, x, y) == true) { 
		// تعليم النقطتين كجزء من مسار الحل
		sol[x][y] = 1; 

		/* التحرّك باتجاه الأمام */
		if (solveMazeUtil(maze, x + 1, y, sol) == true) 
			return true; 

		/* x إن لم تؤد الحركة بالاتجاه الأمامي على المحور
		 y إلى الوصول للحلّ، تحرّكنا بالاتجاه السفلي على المحور */
		if (solveMazeUtil(maze, x, y + 1, sol) == true) 
			return true; 

		/* إن لم تنفع الحركتان السابقتان في التوصل إلى الحل ننفّذ أسلوب التعقب الخلفي
		y و x وذلك بإلغاء تعليم النقتطين 
		كجزء من مسار الحل */
		sol[x][y] = 0; 
		return false; 
	} 

	return false; 
} 

// اختبار الدوال السابقة
int main() 
{ 
	int maze[N][N] = { { 1, 0, 0, 0 }, 
		       	{ 1, 1, 0, 1 }, 
			{ 0, 1, 0, 0 }, 
			{ 1, 1, 1, 1 } }; 

	solveMaze(maze); 
	return 0; 
}

</pre>
</p>
</div>
  <h3>   : N Queen  problem  - مسألة الوزراء الثمان  </h3>
  <p class="content-p">
  تعتبر مشكلة الثمان وزراء أحدى الأمثلة عن الخوارزمية التراجعية 
فهي تشرح كيف يمكننا وضع ثمانية وزراء على رقعة شطرنج بحيث يكون كل وزير في مكان أمن لا يهاجم أحدهما الأخر على سبيل المثال الصورة التالية تعرض الحل من أجل أربعة وزراء
</p>
  <br/><img class="content-image" src="/assets/img/algorithms/N-Queen.jpg" alt="images/ratinmaze1"/>
<h5><bdi>الخرج المتوقع عبارة عن مصفوفة ثنائية ويدل الرقم 1 على مكان توضع الوزراء المثال التالي يوضح مصفوفة الخرج لحل مشكلة الأربع وزراء </bdi></h5>
    <div class="code-box">
 <p class="content-p">
<pre style="line-height: 1.5em;">
{ 0,  1,  0,  0}
{ 0,  0,  0,  1}
{ 1,  0,  0,  0}
{ 0,  0,  1,  0}
</pre>
</p>
</div>
<h4> : الخوارزمية </h4>
<p class="content-p">
إنشاء كافة الخيارات الممكنة للوزراء على الرقعة وطباعة الخيارات التي تحقق الشروط
</p>
    <div class="code-box">
 <p class="content-p">
<pre style="line-height: 1.5em;">
طالما يوجد خيارات لم يتم تجربتها
{
   إنشاء الخيار التالي 
إذا الوزراء في مكان أمن ولا تهاجم    
   {
      طباعة هذا الخيار 
   }
}                                                                       
</pre>
</p>
</div>
<h4> : الخوارزمية التراجعية </h4>
<p class="content-p">
الفكرة هي وضع الوزراء واحد تلو الأخر في أعمدة مختلفة بدءا من العامود الموجود في أقصى اليسار عندما نضع الوزير في العامود نتحقق من كونه في مكان أخر بالنسبة للوزراء الموضوعين سابقا في العمود الحالي إذا وجدنا صف امن لا يمكن مهاجمته فإننا نضع علامة على هذا الصف والعامود كجزء من الحل إذا لم نستطيع إيجاد صف بسبب الاشتباكات مع باقي الوزراء نقوم بالتراجع عن هذه الخطوة وإرجاع قيمة خاطئة 
<br>
 	البدء من العامود الموجود في أقصى اليسار -
<br>
	إذا كل الوزراء تم وضعها نقوم بإرجاع قيمة صحيحة -
<br>
	محاولة كل الصفوف في العامود الحالي -
</p>
<h6> : نقوم بالخطوات التالي لكل صف نقوم باختباره </h6>
<p class="content-p">
  	 إذا كان الوزير يمكن وضعه بشكل أمن في هذا الصف ونقوم بوضع علامة على هذا الصف والعامود كجزء من الحل وبشكل عودي نتحقق إذا كان وضع - الوزير هنا يؤدي إلى حل 
<br>
	إذا كان وضع الوزير في هذا العامود والصف  يؤدي إلى حل نقوم بإرجاع قيمة صحيحة -
	<br>
	<bdi>	إذا كان وضع الوزير هنا لا يؤدي إلى حل نزيل العلامة ونقوم بالتراجع ونذهب إلى الخطوة a لتجريب صف أخر </bdi> -
	<br>
	إذا كانت كل الصفوف تمت تجريبها ولا ينجح شيء نعيد قيمة خاطئة لتحريك التراجع -
	</p>
    <div class="code-box">
 <p class="content-p">
<pre style="line-height: 1.5em;">
#include <bits/stdc++.h>
#define N 4 
// دالة مساعدة لطباعة النتيجة
void printSolution(int board[N][N]) 
{ 
	for (int i = 0; i < N; i++) { 
		for (int j = 0; j < N; j++) 
			printf(" %d ", board[i][j]); 
		printf("\n"); 
	} 
} 

/* board[row][col] دالة مساعدة للتحق من إمكانية وضع الملكة في الموقع 
لاحظ أنّ هذه الدالة تستدعى عندما توضع الملكات في الأعمدة من العمود الأول إلى العمود الأخير
لذا سنحتاج إلى التحقق من هجوم الملكات من الجانب الأيسر فقط */

bool isSafe(int board[N][N], int row, int col) 
{ 
	int i, j; 

	/* تحقّق من هذا الصف من الجانب الأيسر */
	for (i = 0; i < col; i++) 
		if (board[row][i]) 
			return false; 

	/* التحقق من الجانب القطري العلوي في الجانب الأيسر */
	for (i = row, j = col; i >= 0 && j >= 0; i--, j--) 
		if (board[i][j]) 
			return false; 

	/* التحقق من الجانب القطري السفلي في الجانب الأيسر */
	for (i = row, j = col; j >= 0 && i < N; i++, j--) 
		if (board[i][j]) 
			return false; 

	return true; 
} 

/* دالة مساعدة تعاودية لحل مسألة ملكات الشطرنج */
bool solveNQUtil(int board[N][N], int col) 
{ 
	/* الحالة الأساس: إن كانت جميع الملكات موضوعة في مكانها، فسنعيد قيمة صحيحة */
	if (col >= N) 
		return true; 

	/* ننظر في هذا العمود ونحاول وضع هذه الملكة في جميع الصفوف واحدًا تلو الآخر */
	for (int i = 0; i < N; i++) { 
		/* board[i][col] التحقق من إمكانية وضع الملكة في الموقع */
		if (isSafe(board, i, col)) { 
			/*  board[i][col] وضع هذه الملكة في الموقع */
			board[i][col] = 1; 

			/* تنفذ العملية تعاوديًا وذلك لوضع بقية الملكات في مواقعها */
			if (solveNQUtil(board, col + 1)) 
				return true; 

			/*  board[i][col] إن لم يؤدِّ وضع الملكة في الموقع
			إلى الوصول إلى حل، تزال الملكة من هذا المكان */
			board[i][col] = 0; // التعقب الخلفي
		} 
	} 

	/* إن لم يكن بالإمكان وضع الملكة في أي صفّ من صفوف هذا العمود تعيد الدالة قيمة خاطئة */
	return false; 
} 

/* تحلّ هذه الدالة مسألة ملكات الشطرنج باستخدام التعقب الخلفي.
solveNQUtil() تعتمد هذه الدالة اعتمادًا كبيرًا على الدالة
في حلّ هذه المسألة. وتعيد قيمة خاطئة في حال عدم إمكانية وضع الملكات بالطريقة المطلوبة
وتعيد قيمة صحيحة وتطبع الناتج في حال وجود الحل
يجب الانتباه إلى وجود أكثر من حل لهذه المسألة وأنّ هذه الدالة
تقدم أحد الحلول الممكنة فقط */
bool solveNQ() 
{ 
	int board[N][N] = { { 0, 0, 0, 0 }, 
						{ 0, 0, 0, 0 }, 
						{ 0, 0, 0, 0 }, 
						{ 0, 0, 0, 0 } }; 

	if (solveNQUtil(board, 0) == false) { 
		printf("Solution does not exist"); 
		return false; 
	} 

	printSolution(board); 
	return true; 
} 

// اختبار الدوال السابقة
int main() 
{ 
	solveNQ(); 
	return 0; 
}

</pre>
</p>
</div>

  <h3>   : The Knight’s tour problem   - مشكلة جولة الحصان  </h3>
  <p class="content-p">
  <bdi>تعتبر هذه المشكلة أحدى المشكلات التي يمكن إيجاد حلها عن طريق التعقب الخلفي حيث يتم اعطاءنا رقعة شطرنج أبعادها N*N حيث يتوضع الحصان في الخانة الأولى من هذه الرقعة ويتم تحريكها وفقا لقواعد لعبة الشطرنج بحيث يزور كل خانة مرة واحدة فقط والمطلوب طباعة ترتيب كل خلية تمت زيارتها </bdi>
  </p>
  <h4> : مثال يوضح المعطيات والمطلوب </h4>
<div class="code-box">
<p class="content-p">
<pre style="line-height: 1.5em;">
الدخل: 
N = 8
الخرج:
0  59  38  33  30  17   8  63
37  34  31  60   9  62  29  16
58   1  36  39  32  27  18   7
35  48  41  26  61  10  15  28
42  57   2  49  40  23   6  19
47  50  45  54  25  20  11  14
56  43  52   3  22  13  24   5
</pre>
</p>
</div>
  <h4> : الطريق الذي يتبعه الفرس لزيارة كل الخلايا  </h4>
  <p class="content-p">
  <bdi>فيما يلي رقعة شطرنج أبعادها 8*8 الأرقام الموجودة في الخلايا تشير إلى عدد تحركات الحصان</bdi>
  </p>
    <br/><img class="content-image" src="/assets/img/algorithms/knight-tour-problem1.png" alt="images/ratinmaze1"/>
<h4>:  دعنا في البداية نناقش الخوارزمية البسيطة ثم نقوم بمناقشة خوارزمية التعقب الخلفي </h4>
  <h5> : الخوارزمية البسيطة لمشكلة جولة الحصان </h5>
  <div class="code-box">
<p class="content-p">
<pre style="line-height: 1.5em;">
تقوم هذه الخوارزمية بإيجاد جميع الحركات واحدة تلو الأخرة والتحقق ما إذا كانت هذه الجولة تحقق شروط المسألة 
طالما يوجد حركات غير مجربة  
{ 
   إيجاد الحركة التالية 
   إذا كانت هذه الجولة تغطي  كل الخانات 
   { 
      طباعة هذا المسار 
   }
}
</pre>
</p>
</div>
 <h5> : خوارزمية التعقب الخلفي  </h5>
<p class="content-p">
التعقب الخلفي يعمل بطريقة تصاعدية لإيجاد الحل حيث نبدأ عادة بمصفوفة حل فارغة ونقوم بإضافة العناصر إليها واحد تلو الأخر (يختلف معنى العنصر من مشكلة إلى أخرى ففي هذه المسألة يمثل حركة الحصان ,عند أضافة العنصر تتحقق  إذا كان هذا العنصر الذي تمت أضافته يخرق شروط المسألة إذا كان يخرق الشروط تتم بإزالته ويتم تحريب حل أخر ,إذا لم ينجح أي حل أخر تعود الخوارزمية  إلى المرحلة السابقة وتقوم بإزالة هذا العنصر الذي تمت أضافته في هذه المرحلة وإذا وصلت الخوارزمية إلى المرحلة الأولى فعندئذ تكون المسالة ليس لها حل  اما في حال كانت أضافة العنصر لا تخرق شروط المسألة يتم أضافة العناصر واحد تلو الأخر بشكل تعاودي إذا أصبحت المصفوفة ممتلئة نقوم بطباعة الحل  
</p>
<h4> : خوارزمية التعقب الخلفي لمشكلة جولة الحصان </h4>
<p class="content-p">
إذا كانت كل الخلايا تمت زيارتها نقوم بطباعة الحل 
<br>
 : وإلا 
<br>
<bdi>1.	نضيف إحدى الحركات التالية إلى مصفوفة الحل ونتحقق بطريقة تعاودية مما إذا كانت هذه الحركة ستوصلنا إلى الحل (يمكن للحصان أن يتحرك 8 حركات كحد أقصى وسنختار إحدى هذه الحركات الثمانية في هذه الخطوة )
</bdi>
<br>
<bdi>2.	إذا لم نصل إلى الحل باستخدام الحركة التي اخترناها في الخطوة السابقة نحذف هذه الحركة من مصفوفة الحل ونجرب حركة أخرى
</bdi>
<br>
<bdi>3.	إذا لم نصل إلى الحل باستخدام أي من الحركات البدلية  نعيد قيمة خاطئة (تؤدي إعادة قيمة خاطئة إلى حذف العنصر المضاف سابقا في عملية التعاود وإن أعاد الاستدعاء الأول قيمة خاطئة  فهذا يعني عدم وجود حل لهذه المسالة 
</bdi>
</p>
<h4>يعرض المثال التالي طريقة حل المسألة باستخدام التعقب الخلفي يطبع الكود التالي الحلول في مصفوفة ثنائية البعد والمخرجات هي عبارة عن مصفوفة أبعادها 8*8 تتضمن هذه المصفوفة أرقام تبدا من الصفر وتنتهي بالرقم 63 وتمثل هذه الأرقام الخطوات التي يؤديها الحصان على لوحة الشطرنج 
</h4>
<div class="code-box">
<p class="content-p">
<pre style="line-height: 1.5em;">
#include <bits/stdc++.h>
#define N 8 

int solveKTUtil(int x, int y, int movei, int sol[N][N], 
				int xMove[], int yMove[]); 

/* دالة مساعدة للتحقق من أنّ القيم المعطاة ملائمة لمصفوفة رقعة الشطرنج */
bool isSafe(int x, int y, int sol[N][N]) 
{ 
	return ( x >= 0 && x < N && y >= 0 && 
			y < N && sol[x][y] == -1); 
} 

/* دالة مساعدة لطباعة مصفوفة الحل */
void printSolution(int sol[N][N]) 
{ 
	for (int x = 0; x < N; x++) 
	{ 
		for (int y = 0; y < N; y++) 
			printf(" %2d ", sol[x][y]); 
		printf("\n"); 
	} 
} 

/* تحلّ هذه الدالة مسألة جولة الحصان باستخدام التعقب الخلفي.
solveKTUtil() تعتمد هذه الدالة اعتمادًا كبيرًا على الدالة
في حلّ هذه المسألة. وتعيد قيمة خاطئة في حال عدم وجود حل لهذه المسألة
وتعيد قيمة صحيحة وتطبع الناتج في حال وجود الحل
يجب الانتباه إلى وجود أكثر من حل لهذه المسألة وأنّ هذه الدالة
تقدم أحد الحلول الممكنة فقط */
bool solveKT() 
{ 
	int sol[N][N]; 

	/* تهيئة مصفوفة الحل */
	for (int x = 0; x < N; x++) 
		for (int y = 0; y < N; y++) 
			sol[x][y] = -1; 

	/* تحدد هاتان المصفوفتان الحركة القادمة للحصان
	xMove[] لحركة الحصان القادمة على المحور السيني
	yMove[] لحركة الحصان القادمة على المحور الصادي */
	
	int xMove[8] = { 2, 1, -1, -2, -2, -1, 1, 2 }; 
	int yMove[8] = { 1, 2, 2, 1, -1, -2, -2, -1 }; 

	// لما كان الحصان في بداية الخوارزمية في الخانة الأولى
	sol[0][0] = 0; 

	/* solveKTUtil() البدء من الخانة 0,0 واستكشاف جميع الحركات باستخدام الدالة */
	if (solveKTUtil(0, 0, 1, sol, xMove, yMove) == false) 
	{ 
		printf("Solution does not exist"); 
		return false; 
	} 
	else
		printSolution(sol); 

	return true; 
} 

/* دالة مساعدة تعاودية تستخدم لحلّ مسألة جولة الحصان */
int solveKTUtil(int x, int y, int movei, int sol[N][N], 
				int xMove[N], int yMove[N]) 
{ 
int k, next_x, next_y; 
if (movei == N*N) 
	return true; 

/* x, y تجربة جميع الحركات القادمة من الموقع الحالي ذي الإحداثيات */

for (k = 0; k < 8; k++) 
{ 
	next_x = x + xMove[k]; 
	next_y = y + yMove[k]; 
	if (isSafe(next_x, next_y, sol)) 
	{ 
		sol[next_x][next_y] = movei; 
		if (solveKTUtil(next_x, next_y, movei+1, sol, 
						xMove, yMove) == true) 
			return true; 
		else
			sol[next_x][next_y] = -1; // التعقب الخلفي
	} 
} 

return false; 
} 

/* اختبار الدالة السابقة */
int main() 
{ 
	solveKT(); 
	return 0; 
}

</pre>
</p>
</div>
