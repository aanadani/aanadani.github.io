---
layout: "content"
categories: computer-science algorithms
title:     "الخوارزمية الجشعة "
permalink: /:categories/:title.html
type: 'course'
---
<div class="col-12">
<h2> greedy algorithms-الخوارزمية الجشعة</h2>
<p class="content-p">
  الخوارزمية الجشعة هي نهج لحل المشكلة عن طريق تحديد الخيار الأفضل المتاح في الوقت الحالي  وهي لا تبالي ما إذا كانت أفضل نتيجة حالية ستجلب النتيجة الأفضل الشاملة 
الخوارزمية لا تقوم بعكس القرار السابق حتى لوكان الاختيار خاطئ فهي تعمل وفق نهج من أعلى إلى أسفل
. الخوارزمية من الممكن ألا تعطي نتيجة أفضل نتيجة لكل المشاكل ولذلك لأنها تتجه نحو الخيار الأفضل المحلي للحصول على افضل نتيجة عامة
<br>
: ومن الممكن تحديد إذا كان يمكن استخدام  هذه الخوارزمية مع أي مشكلة وذلك  إذا كان للمشكلة هذه الخصائص 
</p>
<h5>: خاصية الاختيار الشجع -</h5>
<p class="content-p">
  إذا كان الحل الأفضل للمشكلة يمكن أيجاده عن طريق اختيار أفضل خيار لكل خطوة دون إعادة النظر في الخطوات السابقة التي تم اختيارها يمكن حل المشكلة باستخدام النهج الجشع هذه الخاصية تدعى خاصية الاختيار الجشع 
</p>
<h5>: البنية الفرعية الأمثل -</h5>
<p class="content-p">
  إذا كان الحل الأمثل للمشكلة يتوافق مع الحلول المثلى لمشكلاتها الفرعية عندها يمكن حل هذه المشكلة باستخدام النهج الجشع وهذه الخاصية تدعى البنية الفرعية الأمثل
</p>
<h4>: إيجابيات النهج الجشع</h4>
<p class="content-p">
   	هذه الخوارزمية أسهل في الوصف •
<br>
 هذه الخوارزمية يمكن أن تؤدي أداء أفضل من باقي الخوارزميات(ولكن ليس في كل الحالات ) •
  </p>
<h4> : سلبيات النهج الجشع </h4>
<p class="content-p">
  كما ذكرنا سابقا الخوارزمية الجشعة لا تعطي دائما الحل الأفضل وهذه هي السلبية الرئيسة للخوارزمية 
على سبيل المثال لنفترض أننا نريد أيجاد أطول مسار في الرسم البياني من الجذر إلى الأوراق دعنا نقوم باستخدام الخوارزمية الجشعة 
</p>
<br/><img class="content-image" src="/assets/img/algorithms/greedy-1.jpg" alt="images/greedy-1"/>
<h4>:  النهج الجشع</h4>
<p class="content-p">
  	دعنا نبدأ بالجذر بالعقدة 20 وقيمة الطفل الأيمن هي 3 وقيمة الطفل الأيسر هي 2-
<br>مشكلتنا هي أيجاد أطول مسار والحل الأمثل في الوقت الحالي هو 3وبالتالي الخوارزمية ستختار 3-
<br>أخيرا قيمة الابن الوحيدة للعقدة 3 هي 1 هذا سيعطينا النتيجة الأخيرة 24=3+1+20-
<br>ولكن هذا ليس الخيار الأفضل يوجد مسار أخر يعطي قيمة أكبر 32=10+2+20 كما هو موضح في الصورة أدناه-
</p>
<br/><img class="content-image" src="/assets/img/algorithms/greedy-2.jpg" alt="images/greedy-2"/>
<p class="content-p">وهكذا نجد أن الخوارزمية الشجعة لا تعطي دائما الحل الأمثل</p>
<h4>  : الخوارزمية الجشعة </h4>
<p class="content-p">
   	في البداية مجموعة الحل (التي تحتوي على الإجابات )فراغة -
<br>في كل خطوة يتم أضافة عنصر إلى مجموعة الحل حتى يتم الوصول إلى الحل -
<br>إذا كان مجموعة الحل مقبولة يتم الاحتفاظ بالعنصر الحالي -
<br>	  وإلا يتم رفض الحل ولا يتم النظر إليه مرة أخرى -
</p>
<h4> : دعونا الان نستخدم هذه الخوارزمية في حل المشكلة الأتية </h4>
<h5> :المشكلة </h5>
<p class="content-p">
عليك إجراء تغير في المبلغ باستخدام أصغر عدد ممكن من القطع النقدية
</p>
<p class="content-p">
<h5> :المبلغ </h5>18$
<h5> :القطع النقدية المتاحة </h5>
        5$ -
   <br> 2$ -
   <br> 1$ -
</p>
<p class="content-p">
 لا يوجد عدد محدد لكل قطعة نقدية تقوم باستخدامها
</p>
<h5> : الحل </h5>
<p class="content-p"> 
<bdi>نقوم بإنشاء مصفوفة فارغة solution-set = { } القطع المتاحة هي {5, 2, 1}-  </bdi>
<br><bdi>من المفترض أن نصل للمبلغ sum = 18 لنبدأ بالمبلغ sum = 0 -  </bdi>
<br><bdi>دائما نختار القطع النقدية الأكبر حتى  <bdi>sum>18</bdi> (عندما نختار أكبر قيمة في كل خطوة نأمل أن نصل إلى الحل بشكل أسرع وهذا ما يسمى الاختيار الشجع الأمثل -</bdi>
<br><bdi>	 sum = 5 في التكرار الأول مجموعة الحلول {5} و -  </bdi>
<br><bdi>	sum = 10 في التكرار الثاني مجموعة الحلول  {5, 5} و -  </bdi>
<br><bdi>	  sum = 15 في التكرار مجموعة الحلول {5, 5, 5} و -  </bdi>
<br> <bdi>sum = 17في التكرار الرابع {5, 5, 5, 2} و -</bdi>
<br> <bdi>(لا يمكننا اختيار 5 لإننا أذا فعلنا ذلك sum = 20 وهو أكبر من 18 لذلك نختار ثاني أكبر قيمة وهي 2 ) </bdi>
<br><bdi>	وبشكل مشابه في التكرار الخامس نختار 1الأن <bdi>sum = 18</bdi> ومجموعة الحلول هي {5, 5, 5, 2, 1}-  </bdi>
</p>
<div class="code-box">
<p>
<pre style="line-height: 1.5em;">
#include <bits/stdc++.h>
using namespace std;
// All denominations of Indian Currency
int deno[] = { 1, 2, 5};
int n = sizeof(deno) / sizeof(deno[0]);
void findMin(int V)
{
    sort(deno, deno + n);

    // Initialize result
    vector&lt;int&gt; solution;
    int sum=0;
    // Traverse through all denomination
    for (int i = n - 1; i >= 0; i--) {

        // Find denominations
        while (V >= deno[i]) {
            V -= deno[i];
            sum+=deno[i];
            solution.push_back(deno[i]);
        }
    }
   for (int i = 0; i < solution.size(); i++)
        cout << solution[i] << " ";
}
// Driver program
int main()
{
    int n = 18;
    cout << "Following is minimal"
         << " number of change for " << n
         << ": ";
    findMin(n);
    return 0;
}
// This is code is contributed by rathbhupendra
</pre>
</p>
</div>
</div>


   

