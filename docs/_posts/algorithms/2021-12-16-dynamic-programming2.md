---
layout: "content"
categories: computer-science algorithms
title: " 2 البرمجة الديناميكية "
permalink: /:categories/:title.html
type: "course"
---

<div class="col-12">
  <h2>
  <bdi>
   Dynamic programming - أمثلة عن البرمجة الدينامكية
  </bdi>
</h2>
<h3>   : Coin change problem - مسألة تصريف العملة  </h3>
<p class="content-p">
 تعتبر مشكلة تصريف العملة أحدى الأمثلة على البرمجة الديناميكية بحيث يتم اعطاءنا مبلغ <bdi>N</bdi> 
   ونريد تصريف هذا المبلغ إلى قطع نقدية أصغر باعتبار أن لدينا عدد غير محدد من القطع  <bdi> s={s1,s2,s3,…..Sn}</bdi>
   المطلوب بكم طريقة يمكننا تصريف هذا المبلغ إلى قطع نقدية أصغر  باعتبار أن ترتيب القطع غير مهم 
<p>
<p class="content-p">
 : على سبيل المثال  <bdi>N=4</bdi>  
  و <bdi> S{1,2,3}</bdi> 
    بالتالي سيكون هناك أربعة طرائق لتصريف هذا المبلغ  
 <p>
 <div class="code-box">
 <p class="content-p">
<pre style="line-height: 1.5em;">
{1, 1, 1, 1}
{1, 1, 2}
{2, 2}
{1, 3}
</pre>
</p>
</div>
<p class="content-p">
ويكون جواب هذه المسألة 4
</p>
<p class="content-p">
 : إذا كان <bdi>N=10</bdi> 
و <bdi>S={2,3,5,6}</bdi> 
فإن الحلول ستكون 
</p>
<div class="code-box">
<p class="content-p">
<pre style="line-height: 1.5em;">
{2, 2, 2, 2, 2}
{2, 2, 3, 3}
{2, 2, 6}
{2, 3, 5}
{5, 5}
</pre>
</p>
</div>
<p class="content-p">
ويكون جواب هذه المسألة 5
</p>
<h4> : البنية الفرعية المثالية </h4>
<h4> : لحساب العدد الإجمالي للحلول يمكننا تقسيم مجموعة الحلول إلى مجموعتين </h4>
<p class="content-p">
<bdi>m </bdi> الحلول التي لا تحتوي على القطعة النقدية ذات الترتيب 
<bdi>Sm </bdi>	أو -
<br>
<bdi>Sm </bdi>	الحلول التي تحتوي على الأقل 
 <bdi>s[m-1] </bdi>واحد على الأقل -
 <br>
   ولو فرضنا أن التابع <bdi>count(S[], m, n) </bdi>
     هي الدالة المسؤولة عن حساب عدد الحلول فيمكن كتابة هذه الدالة على شكل مجموع تابعين    <bdi>count(S[], m-1, n)</bdi>
   و - <bdi>count(S[], m, n-Sm)</bdi>  
  
</p>
<p class="content-p">
وبالتالي هذه المشكلة لديها خاصية البنية الفرعية المثالية وهذا يعني يمكن إيجاد حل المسألة بإيجاد حلول المسائل الفرعية 
</p>
<h4> : تداخل المشكلات الفرعية </h4>
<p class="content-p">
فيما يلي تنفيذ عودي بسيط لمشكلة تصريف العملة ويتبع التنفيذ ببساطة الهيكل العودي المذكور أعلاه 
</p>
<h4> : الخوارزمية </h4>
<p class="content-p">	
بشكل أساسي إذا كنا عند <bdi>s[m-1]</bdi>
يمكننا أن نأخذ العديد من الحالات من هذه العملة <bdi>count(S, m, n – S[m-1] )  </bdi>
ثم ننتقل إلى <bdi>s[m-2]</bdi>
وبعد الانتقال إلى <bdi>s[m-2]</bdi>
لا يمكننا العودة للوراء ولا يمكننا أن نجعل خيارات ل <bdi>  count(S, m-1, n ) s[m-1] </bdi>
أخيرا المطلوب منا إيجاد العدد الكلي من الطرق لذلك سوف نجمع هذان الخياران <bdi>count(S, m, n – S[m-1] ) + count(S, m-1, n ) </bdi>
والتي ستكون هي الإجابة المطلوبة 
</p>
<div class="code-box">
<p class="content-p">
<pre style="line-height: 1.5em;">
#include <bits/stdc++.h>
// تعيد الدالة عدد الطرق التي يمكن فيها جميع
// S[0...m-1] عملة
// n للحصول على المجموع
int count( int S[], int m, int n ) 
{ 
	// n إن كان الصفر هو قيمة 
	// فهذا يعني وجود حل واحد
	// (عدم إضافة أي عملة)
	if (n == 0) 
		return 1; 
	
	// إن كانت قيمة n أقل من الصفر
	// لا وجود لأي حل لهذه المسألة
	if (n < 0) 
		return 0;

    // إن لم يكن هناك أي عملة
    // وكانت قيمة n أكبر من 0
    // فهذا يعني عدم وجود أي حل لهذه المسألة
    if (m <=0 && n >= 1)
    	return 0;

    // count مجموع الحلول
    // (1) S[m -1] من ضمنها
    // (2) S[m - 1] ليس من ضمنها
    return count( S, m - 1, n ) + count( S, m, n-S[m-1] );

}

// اختبار الدالة السابقة
int main()
{
int i, j;
int arr[] = {1, 2, 3};
int m = sizeof(arr)/sizeof(arr[0]);
printf("%d ", count(arr, m, 4));
getchar();
return 0;
}

</pre>
</p>
</div>
<h3>   : Knapsack problem - مسألة حقيبة الظهر  </h3>
<p class="content-p">
تعتبر هذه المسألة أحدى المسائل التي يمكننا حلها بواسطة البرمجة الديناميكية  والمطلوب هو وضع مجموعة من العناصر ذات أوزان مختلفة وقيم محددة في حقيبة تتسع لعدد محدد من العناصر مع مراعاة الحصول على أكبر قيمة ممكنة لمجموع قيم العناصر الموجودة في الحقيبة بشرط وضع العنصر كاملا 
وبمعنى آخر، هناك مصفوفتان من الأعداد الصحيحة <bdi>val[0..n-1]</bdi>
و<bdi>wt[0..n-1]</bdi>
واللتان تمثّلان قيم وأوزان العناصر المراد وضعها في الحقيبة ذات الوزن <bdi>W </bdi>والمطلوب هو إيجاد أكبر مجموعة فرعية من المصفوفة <bdi>val[]</bdi>
بشرط أن يكون مجموع أوزان العناصر في هذه المجموعة الفرعية أصغر من سعة الحقيبة أو مساويًا لها، مع ملاحظة أنّه لا يسمح بتقسيم العناصر فإمّا أن يوضع العنصر كاملًا أو أنّه لن يدخل الحقيبة.
الحلّ البسيط لهذه المسألة هو النظر في جميع المجاميع الفرعية التي يمكن إنشاؤها وحساب الوزن الكلي والقيمة الكلية لها، ثم النظر في المجموعات الفرعية التي يكون وزنها الكلي أصغر من سعة الحقيبة، ثم اختيار المجموعة الفرعية التي تمتلك أكبر مقدار للقيمة.
</p>
<h4> : البنية الفرعية المثالية </h4>
<h5> : يمكن ملاحظة حالتين لكل عنصر عند النظر إلى كل المجموعات الفرعية من العناصر </h5>
<p class="content-p">
	العنصر موجود في المجموعة الفرعية المثالية -
    <br>
    	العنصر غير موجود في المجموعة الفرعية المثالية -
</p>
<h5>: هذا يعني أن القيمة العظمى التي يمكن الحصول عليها من <bdi>n</bdi> 
عنصر هي القيمة العظمة من بين القيمتين التاليتين </h5>
<p class="content-p">
	 <bdi>n</bdi> القيمة العظمى التي يمكن الحصول عليها من <bdi>n-1</bdi> 
    عنصر ومن وسعة الحقيبة <bdi>W</bdi>
  من دون العنصر ذو الترتيب 
<br>
    	قيمة العنصر ذي الترتيب <bdi>n</bdi>
        إضافة إلى القيمة العظمى التي يمكن الحصول عليها من <bdi>n-1</bdi>
        عنصر وسعة الحقيبة <bdi>W</bdi>مطروحًا منه وزن العنصر ذي الترتيب 
        مع العنصر ذي الترتيب <bdi>n</bdi>         
<br>
 إن كان وزن العنصر ذي الترتيب <bdi>n</bdi>أكبر من وزن الحقيبة فلن يكون بالإمكان أضافة هذا العنصر إلى الحل وستكون الحالة الأولى هي الاحتمال الوحيد لهذه المسألة 
</p>
<div class="code-box">
<p class="content-p">
<pre style="line-height: 1.5em;">
#include <bits/stdc++.h> 
using namespace std; 
// دالة مساعدة تعيد القيمة الأكبر بين القيمتين المعطاتين
int max(int a, int b) { return (a > b)? a : b; } 

// W تعيد الدالة أكبر قيمة يمكن وضعها في حقيبة الظهر ذات السعة
int knapSack(int W, int wt[], int val[], int n) 
{ 
	
// الحالة الأساس
if (n == 0 || W == 0) 
	return 0; 

// إن كان وزن العنصر ذي الترتيب المعطى
// أكبر من سعة حقيبة الظهر فليس بالإمكان
// إضافة هذا العنصر إلى الحل المثالي
if (wt[n-1] > W) 
	return knapSack(W, wt, val, n-1); 

// تعيد الدالة أكبر قيمة من بين الحالتين:
// (1) تضمين العنصر ذي الترتيب المعطى
// (2) عدم تضمين العنصر
else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),knapSack(W, wt, val, n-1) ); 
} 

// اختبار الدوال السابقة
int main() 
{ 
	int val[] = {60, 100, 120}; 
	int wt[] = {10, 20, 30}; 
	int W = 50; 
	int n = sizeof(val)/sizeof(val[0]); 
	cout<<knapSack(W, wt, val, n); 
	return 0; 
}
</pre>
</p>
</div>