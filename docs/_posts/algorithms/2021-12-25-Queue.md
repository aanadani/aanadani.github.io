---
layout: "content"
categories: computer-science algorithms
title:     " الرتل    "
permalink: /:categories/:title.html
type: 'course'
---
<div class="col-12">
<h2>  Queue -  الرتل  </h2>
<p class="content-p">
<bdi> 
يعتبر الqueue أو ما يسمى بالرتل هي بنية معطيات خطية تعتبر مفيدة جدا في البرمجة وهي تشبه طابور التذاكر في قاعة السينما
حيث يكون أول شخص يدخل قائمة الانتظار هو أول شخص يحصل على التذكرة 
حيث تتبع قاعدة FIFO العنصر الذي يدخل أولا هو العنصر الذي يخرج أولا
</bdi></p>
 <br/><img class="content-image" src="/assets/img/algorithms/queue1.jpg" alt="images/queue1"/>
<p class="content-p"><bdi>
في الصورة الموجودة في الأعلى عندما تم إضافة العنصر الأول 1 قبل العنصر الثاني 2 فنجد أن العنصر الأول هو الذي سوف تتم ازالته أولا من الرتل 
في البرمجة وضع العناصر في الرتل يدعى enqueue وإزالة العناصر من قائمة الانتظار يدعى dequeue
</bdi></p>
<h4> : العمليات الأساسية في الارتال </h4>
<p class="content-p"><bdi>
إضافة عنصر إلى نهاية الرتل : enqueue
<br>
حذف عنصر من بداية الرتل : dequeue
<br>
التحقق إذا كان الرتل فارغ:IsEmpty
<br>
التحقق إذا كان الرتل ممتلئ:IsFull
<br>
الحصول على قيمة أخر عنصر بدون حذفه:Peek
</bdi></p>
<h4> : طريقة عمل الارتال </h4>
<p class="content-p"><bdi>
•	يتم إنشاء مؤشرين FRONT و REAR
<br>
•	FRONT يقوم بتتبع العنصر الأول في الرتل 
<br>
•	REAR يقوم بتتبع العنصر الأخير في الرتل 
<br>
•	نقوم بإعطاء قيمة 1- لكل من FRONT و REAR
</bdi></p>
<h4>  : عملية الإضافة  </h4>
<p class="content-p"><bdi>
•	نتحقق إذا كان الرتل ممتلئ
<br>
•	للعنصر الأول نجعل قيمة FRONT 0
<br>
•	نزيد قيمة REAR بمقدار 1
<br>
•	إضافة العنصر الجديد في الموقع الذي يشير إليه REAR
</bdi></p>
<h4>   : عملية الحذف    </h4>
<p class="content-p"><bdi>
•	التحقق إذا كان الرتل فارغ
<br>
•	إعادة القيمة التي يشير إليها FRONT
<br>
•	زيادة قيمة FRONT بمقدار 1
<br>
•	اذا كنا نريد حذف اخر عنصر في الرتل نجعل قيمة كل من FRONT و REAR 1-
</bdi></p>
<br/><img class="content-image" src="/assets/img/algorithms/queue2.jpg" alt="images/queue2"/>
<h4> : عادة نقوم بتطبيق الارتال بواسطة المصفوفات </h4>
<div class="code-box">
<p class="content-p">
<pre style="line-height: 1.5em;">
// Queue implementation in C++
#include <bits/stdc++.h>
#define SIZE 5
using namespace std;
class Queue {
   private:
  int items[SIZE], front, rear;

   public:
  Queue() {
    front = -1;
    rear = -1;
  }

  bool isFull() {
    if (front == 0 && rear == SIZE - 1) {
      return true;
    }
    return false;
  }

  bool isEmpty() {
    if (front == -1)
      return true;
    else
      return false;
  }

  void enQueue(int element) {
    if (isFull()) {
      cout << "Queue is full";
    } else {
      if (front == -1) front = 0;
      rear++;
      items[rear] = element;
      cout << endl
         << "Inserted " << element << endl;
    }
  }

  int deQueue() {
    int element;
    if (isEmpty()) {
      cout << "Queue is empty" << endl;
      return (-1);
    } else {
      element = items[front];
      if (front >= rear) {
        front = -1;
        rear = -1;
      } /* Q has only one element, so we reset the queue after deleting it. */
      else {
        front++;
      }
      cout << endl
         << "Deleted -> " << element << endl;
      return (element);
    }
  }

  void display() {
    /* Function to display elements of Queue */
    int i;
    if (isEmpty()) {
      cout << endl
         << "Empty Queue" << endl;
    } else {
      cout << endl
         << "Front index-> " << front;
      cout << endl
         << "Items -> ";
      for (i = front; i <= rear; i++)
        cout << items[i] << "  ";
      cout << endl
         << "Rear index-> " << rear << endl;
    }
  }
};

int main() {
  Queue q;

  //deQueue is not possible on empty queue
  q.deQueue();

  //enQueue 5 elements
  q.enQueue(1);
  q.enQueue(2);
  q.enQueue(3);
  q.enQueue(4);
  q.enQueue(5);

  // 6th element can't be added to because the queue is full
  q.enQueue(6);

  q.display();

  //deQueue removes element entered first i.e. 1
  q.deQueue();

  //Now we have just 4 elements
  q.display();

  return 0;
}

</pre>
</p>
</div>
<h4><bdi>التعقيد الزمني ل Queue:</bdi></h4>
<p class="content-p">
<bdi>تعقيد عمليات الإضافة والحذف باستخدام المصفوفات يستغرق زمنا ثابتا O(1)</bdi></p>
<h4><bdi>أنواع ال Queue:</bdi></h4>
<h4> : هناك أربعة أنواع مختلفة من الارتال </h4>
<h5><bdi>• الارتال البسيطة :</bdi></h5>
<p class="content-p">
<bdi>في هذا النوع يتم إضافة العناصر في الخلف rear و تقوم بحذف العناصر من الامام Front  حيث يستخدم قاعدة FIFO</bdi></p>
<br/><img class="content-image" src="/assets/img/algorithms/queue3.jpg" alt="images/queue3"/>
<h5><bdi>•	الارتال الدائرية:</bdi></h5>
<p class="content-p">
<bdi>في هذا النوع يشير العنصر الأخير إلى العنصر الأول الذي يقوم بعمل ارتباط دائري ويتميز هذا النوع عن الارتال البسيطة في استخدام الذاكرة بشكل أفضل إذا كان الموقع الأخير ممتلئ والموضع الأول فارغ يمكننا أضافة عنصر في الموقع الأول وهذا الاجراء غير ممكن في النوع البسيط</bdi></p>
<br/><img class="content-image" src="/assets/img/algorithms/queue4.jpg" alt="images/queue4"/>
<h5><bdi>•	الارتال الأولوية:</bdi></h5>
<p class="content-p">يعتبر نوع خاص من الارتال التي يقترن كل عنصر فيها بالأولوية ويتم تقديمه وفقا للأولوية الخاصة به إذا كان للعناصر نفس الأولوية يتم تقديمها وفقا لترتيبها في الرتل 
الإضافة تحدث اعتمادا على الوصول للقيم والحذف يحدث تبعا للأولوية
 </p>
 <br/><img class="content-image" src="/assets/img/algorithms/queue5.jpg" alt="images/queue5"/>
 <h5><bdi>•	الارتال المزدوجة المنتهية:</bdi></h5>
 <p class="content-p"><bdi>في هذا النوع يمكن إضافة العناصر أو حذفها من الأمام والخلف ولا يتبع قاعدة FIFO</bdi></p>
 <br/><img class="content-image" src="/assets/img/algorithms/queue6.jpg" alt="images/queue6"/>
<h4><bdi>تطبيقات ال Queue:</bdi></h4>
<p class="content-p">
<bdi>
•	جدولة وحدة المعالجة المركزية والاقراص
<br>
•	عندما يتم نقل البيانات بشكل غير متزامن بين عملتين يتم استخدام الأرتال للمزامنة على سبيل المثال  IO Buffers, pipes, file IO
<br>
•	معالجة المقاطعات في أنظمة الوقت الحالي
<br>
•	أنظمة الهاتف في مراكز الاتصال تستخدم الأرتال لتنظيم دور الاتصال 
</bdi></p>
</div>